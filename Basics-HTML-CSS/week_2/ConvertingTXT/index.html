<!DOCTYPE html>
<html>

<head>
    <title> ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ </title>
    <meta charset="utf-8">
    <script src="http://fred-wang.github.io/mathjax.js/mpadded-min.js"></script>
</head>

<body>
    <hgroup align="center">
        <header>
            <h1>Блог компании Яндекс.</h1>
        </header>
        <h2>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h2>
    </hgroup>
    
    <p>
        Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,
        какой он красивый, ни то, какой он удобный.<wbr> Никому не понравится, когда все
        тормозит.<wbr> Мы регулярно добавляем в Яндекс.<wbr>Почту новую функциональность,
        иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код
        и новая логика.<wbr> Всё это напрямую влияет на скорость работы интерфейса.<wbr>
    </p>

    <main>
        <section>
            <h2 align="center">Что мы измеряем</h3>
    
            Этапы первой загрузки:
            <ul type="square">
                <li>подготовка;</li>
                <li>загрузка статики (<abbr title="HyperText Transfer Protocol">HTTP</abbr>-запрос и парсинг);</li>
                <li>исполнение модулей;</li>
                <li>инициализация базовых объектов;</li>
                <li>отрисовка;</li>
            </ul>
            
            Этапы отрисовки любой страницы:
            <ul type="circle">
                <li>подготовка к запросу на сервер;</li>
                <li>запрос данных с сервера;</li>
                <li>шаблонизация;</li>
                <li>обновление <abbr title="Document Object Model">DOM</abbr>;</li>
            </ul>

            <cite>— «Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы</cite><br>
            <cite>— «Что же дальше?» - вопрошаете вы</cite><br>
            <cite>— «А давай построим график!» - отвечаем мы</cite><br>
            <cite>— «А что будем считать?» - уточняете вы</cite><br>

            
            <p> 
                Как вы знаете, <dfn id="mediana">медиана</dfn> – это серединное, а не среднее значение в выборке.<br>
                Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
                В общем случае медиана отлично показывает, сколько грузится средний пользователь.
            </p>

            <p>
                В случае ускорения или замедления медиана, конечно, изменится. Но она не может
                рассказать, сколько пользователей ускорилось, а сколько замедлилось.
            </p>

            <p>
                <dl>
                    <dt>
                        <dfn>APDEX</dfn>
                    </dt>
                    <dd>
                        – метрика, которая сразу говорит: хорошо или плохо.
                    </dd>
                </dl>
                
                Метрика работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
                время показа страницы попало в него, то пользователь счастлив. Берем еще один
                интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
                показана за это время, то пользователь в целом удовлетворен скоростью работы,
                но уже не настолько счастлив. И применяем формулу:

                <p align="center">
                    <math>
                        <mfrac>
                            <mrow>
                                <mfrac>
                                    <mrow>
                                        <mtext>кол-во счастливых пользователей</mtext>
                                            <mo>+</mo>
                                        <mtext>кол-во удовлетворенных</mtext>
                                    </mrow>
                                    <mrow>
                                        <mn>2</mn>
                                    </mrow>
                                </mfrac>
                            </mrow>
                            <mrow>
                                <mtext>кол-во всех</mtext>
                            </mrow>
                        </mfrac>
                    </math>
                </p>
                
                Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
                хорошо или плохо работает почта.
            </p>
        </section>

        <section>
            <h2 align="center">Как мы измеряем</h3>
            
            Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
            причину замедления: медленнее стал отвечать сервер либо слишком долго
            выполняется JavaScript.<br> Выглядит это примерно так:
            <p align="center">
                <code>
                    this.timings['look-ma-im-start'] = Date.now();<br>
                    this.timings['look-ma-finish'] = Date.now();
                </code>
            </p>

            C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при
            отправке рассчитываются. На этапах разница между “end” и “start” не считается,
            а все вычисления производятся в конце:
            <p align="center">
                <code>
                    var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
                </code>
            </p>

            И на сервер прилетают подобные записи:
            <p align="center">
                <math>
                    <mrow>
                        <mi>serverresponse</mi>
                            <mo>=</mo>
                        <mn>50</mn>
                            <mo>&</mo>
                        <mi>domUpdate</mi>
                            <mo>=</mo>
                        <mn>60</mn>
                    </mrow>
                </math>
            </p>
        </section>

        <section>
            <h2 align="center">Как мы ускоряем</h3>
            
            Чтобы снизить время загрузки почты при выходе новых версий,
            мы уже делаем следующее:
            <ul type="square">
                <li>включаем gzip;</li>
                <li>выставляем заголовки кэширования;</li>
                <li>фризим <abbr title="Cascading Style Sheets">CSS</abbr>, <abbr title="JavaScript">JS</abbr>, шаблоны и картинки;</li>
                <li>используем CDN;</li>
            </ul>

            <p>
                Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой
                передавать только diff между ней и той, которая сохранена у пользователя?</q>
                В браузере же останется просто наложить патч на клиенте.
            </p>

            <p>
                На самое деле эта идея не нова. Уже существуют стандарты для <abbr title="HyperText Transfer Protocol">HTTP</abbr> — например,
                RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
                не получили должного распространения в браузерах и на серверах.
            </p>

            <dl>
                <dt>
                    Мы же решили сделать свой аналог на <abbr title="JavaScript">JS</abbr>. Чтобы реализовать этот метод обновления,
                    начали искать реализации diff на <abbr title="JavaScript">JS</abbr>. На популярных хостингах кода нашли
                    библиотеки:
                    <dd><li>VCDiff</li></dd>
                    <dd><li>google-diff-patch-match</li></dd>
                </dt>
            </dl>
            
            <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
            <table align="center" border="2" cellspacing="1" width="300">
                <tr>
                    <th>Библиотека</th> 
                    <th>IE 9</th>
                    <th>Opera 12</th>
                </tr>

                <tr>
                    <td>vcdiff</td>
                    <td>8</td>
                    <td>5</td>
                </tr>

                <tr>
                    <td>google diff</td>
                    <td>1363</td>
                    <td>76</td>
                </tr>
            </table>

            <p>
                После того как мы определились с библиотекой для диффа, нужно определиться с тем,
                где и как хранить статику на клиенте.
            </p>

            <p>
                Формат файла с патчами для проекта выглядит так:
                <pre>
                    <code>
                        [
                            {
                                "k": "jane.css",
                                "p": [patch],
                                "s": 4554
                            },
                            {
                                "k": "jane.css",
                                "p": [patch],
                                "s": 4554
                            }
                        ]
                    </code>
                </pre>
            </p>

            <p>
                <dl>
                    <dt>
                        То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
                        каждого объекта есть три свойства:
                        <dd><var>k</var> — названия ключа в localStorage для этого ресурса;</dd>
                        <dd><var>p</var> — патч для ресурса, который сгенерировал vcdiff;</dd>
                        <dd><var>s</var> — чексумма для ресурса актуальной версии, чтобы потом можно было проверить правильность,</dd>
                    </dt>
                    
                </dl>
                наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
                
                <p>
                    <dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (<abbr title="Broyden — Fletcher — Goldfarb — Shanno algorithm">BFGS</abbr>)</dfn>
                    — итерационный метод численной оптимизации, предназначенный для
                    нахождения локального максимума/минимума нелинейного функционала
                    без ограничений.<br>

                    <img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/bxX0F__8Eea3FxIaEbBXjA_012f5cdeec268cf6a3f89c5b926f75ab_1111.png?expiry=1594425600000&hmac=fnmU-By1_NxWRD4cyZ_IQWwtkdAJhPTfzmC5TjU3_jI" alt="алгоритм Флетчера">
                </p>
                
                Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
                <dfn><abbr title="Cyclic redundancy check">CRC</abbr>16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки
                целостности данных
                <dfn><abbr title="Message Digest 5">md5</abbr></dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
                или дайджестов сообщения произвольной длины и последующей проверки
                их подлинности. 
                
                <p>Потому что он быстрый, компактный и легок в реализации.</p>
            </p>
        </section>        

        <section>
            <h2 align="center">Итог</h3 >
    
            <p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
    
            <table align="center" border="2" cellspacing="1" width="300">
                <tr>
                    <th>Релиз</th>
                    <th>С патчем</th>
                    <th>Без патча</th>
                </tr>
    
                <tr>
                    <td>7.7.20</td>
                    <td>397</td>
                    <td>174 549</td>
                </tr>
    
                <tr>
                    <td>7.7.21</td>
                    <td>383</td>
                    <td>53 995</td>
                </tr>
    
                <tr>
                    <td>7.7.21</td>
                    <td>483</td>
                    <td>3 995</td>
                </tr>
            </table>
        </section>
    </main>

    <address>
        Автор: @doochik<br>
        С++ разработчик<br>
        Электронная почта: (<a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a>)<br>
        Компания: Яндекс<br>
    </address>

    <section>
        <h4>Комментарии (3):</h4>

        <p>
            <b>- Mogaika (<a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a>) <time datatime="2014-11-30T17:05+03:00">30 ноября 2014 в 17:05</time></b><br>

            А можете привести сравнение, на сколько быстрее грузится lite версия?
        </p>

        <p>
            <b>- JIguse (<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a>) <time datatime="2014-11-29T21:30+03:00">29 ноября 2014 в 21:30</time></b><br>

            Спасибо за статью, познавательно.<br>
            Здорово, что Яндекс делится некоторыми подробностями о внутренней работе сервисов.
        </p>

        <p>
            <b>- Brister (<a href="mailto:brist89@yandex-team.ru")>brist89@yandex-team.ru</a> <time datatime="2014-11-24T13:13+03:00">24 ноября 2014 в 13:13</time></b><br>

            <p>
                <math>
                    <mfrac>
                        <mrow>
                            <mfrac>
                                <mrow>
                                    <mtext>кол-во счастливых пользователей</mtext>
                                        <mo>+</mo>
                                    <mtext>кол-во удовлетворенных</mtext>
                                </mrow>
                                <mrow>
                                    <mn>2</mn>
                                </mrow>
                            </mfrac>
                        </mrow>
                        <mrow>
                            <mtext>кол-во всех</mtext>
                        </mrow>
                    </mfrac>
                </math>
            </p>
            <cite>
                <q>
                    Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
                    хорошо или плохо работает почта.
                </q>
            </cite>
            
            <p>наверное все-таки от 0.5 до 1</p>
        </p>

        <p>
            <b>- alexeimois (<a href="mailto:test@yandex.ru">test@yandex.ru</a>) <time datatime="2014-11-22T17:35+03:00">22 ноября 2014 в 17:35</time></b><br>

            Мы измеряем скорость загрузки с помощью Яндекс.Метрики:<br>
            <a href="help.yandex.ru/metrika/reports/monitoring_timing.xml">help.yandex.ru/metrika/reports/monitoring_timing.xml</a>
        </p>


    </section>

    <footer>
        <small>&copy; Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</small>
    </footer>
</body>

</html>